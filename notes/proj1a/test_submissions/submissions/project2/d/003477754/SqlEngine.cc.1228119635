/**
 * Copyright (C) 2008 by The Regents of the University of California
 * Redistribution of this file is permitted under the terms of the GNU
 * Public License (GPL).
 *
 * @author Junghoo "John" Cho <cho AT cs.ucla.edu>
 * @date 3/24/2008
 */

#include <cstdio>
#include <iostream>
#include <fstream>
#include "Bruinbase.h"
#include "SqlEngine.h"
#include "BTreeIndex.h"
#include "BTreeNode.h"

using namespace std;

// external functions and variables for load file and sql command parsing 
extern FILE* sqlin;
int sqlparse(void);

//===== Proxy functions =====

void SqlEngine::print_tuple(int attr, int key, std::string value)
{
	// print the tuple 
	switch (attr) 
	{
		case 1:  // SELECT key
			fprintf(stdout, "%d\n", key);
			break;
		case 2:  // SELECT value
			fprintf(stdout, "%s\n", value.c_str());
			break;
		case 3:  // SELECT *
			fprintf(stdout, "%d '%s'\n", key, value.c_str());
			break;
	}	
}

bool SqlEngine::check_cond(SelCond condition, int diff)
{
	// skip the tuple if condition is not met
	switch (condition.comp) 
	{
		case SelCond::EQ:
			if (diff != 0) return false;
			break;
		case SelCond::NE:
			if (diff == 0) return false;
			break;
		case SelCond::GT:
			if (diff <= 0) return false;
			break;
		case SelCond::LT:
			if (diff >= 0) return false;
			break;
		case SelCond::GE:
			if (diff < 0) return false;
			break;
		case SelCond::LE:
			if (diff > 0) return false;
			break;
	}
	
	return true;
}


//===== End Proxy functions =====


RC SqlEngine::run(FILE* commandline)
{
  fprintf(stdout, "Bruinbase> ");

  // set the command line input and start parsing user input
  sqlin = commandline;
  sqlparse();  // sqlparse() is defined in SqlParser.tab.c generated from
               // SqlParser.y by bison (bison is GNU equivalent of yacc)

  return 0;
}

RC SqlEngine::select(int attr, const string& table, const vector<SelCond>& cond)
{
	RecordFile rf;   // RecordFile containing the table
	BTreeIndex bti;  // BTreeIndex object
	RecordId   rid;  // record cursor for table scanning

	RC     	rc;
	int    	key, count, diff;     
	string 	value;
	bool	isIndex = false;
  
	// open the table file
	if ((rc = rf.open(table + ".tbl", 'r')) < 0) 
	{	
		fprintf(stderr, "Error: table %s does not exist\n", table.c_str());
		return rc;
	}
    
	//check if btreeIndex exists 
	if( ((rc = bti.open(table, 'r')) == 0) )
	{
		//cout<<"index found "<<endl;	
		isIndex = true;
	}
	//===== Set up ends =====
  
	//===== Begin logic =====
	//set doIndex true if at least one of the condition check is on key 
	bool 	doIndex 	= false;
	bool 	isEmptySet 	= false;
	
	int 	l_bound		= -1;
	int		u_bound		= -1;
	int		keyEqual 	= -1;
	int 	cond_value;
	
	bool	haveAttrValue = false;
	bool	printTuple	= true;
	string	str_value 	= "";
	SelCond	value_condition;
	
	
	//check conditions with BTreeIndex existing
	for( int i = 0 ; i < cond.size(); i++ )
	{
		//attribute to check is key
		if(cond[i].attr == 1)
		{
			cond_value = atoi(cond[i].value);
			
			//if condition is > or >=, replace with higher 
			//if condition is < or <=, replace with lower
			switch (cond[i].comp) 
			{
				case SelCond::EQ:
					//first encounter of keyEqual
					if(keyEqual == -1) 
					{ keyEqual = cond_value; }
					//if a second keyEqual condition is found with different key value then emptySet is true
					else if( cond_value != keyEqual) 
					{ isEmptySet = true;  }
					break;
				case SelCond::GT:
					if ( (l_bound == - 1) || (l_bound < (cond_value + 1)) )
						l_bound = cond_value + 1;
					break;
				case SelCond::GE:
					if ( (l_bound == - 1) || (l_bound < cond_value ) )
						l_bound = cond_value;
					break;
				case SelCond::LT:
					if ( (u_bound == - 1) || (u_bound > (cond_value - 1)) )
						u_bound = cond_value - 1;
					break;
				case SelCond::LE:
					if ( (u_bound == - 1) || (u_bound > cond_value) )
						u_bound = cond_value;
					break;
			}
			
			doIndex = true;
		}
		//attribute to check is value
		else
		{
			haveAttrValue = true;
			//first encounter of value comparator, set str_value
			if( strcmp( str_value.c_str(), "" ) == 0 )
			{ 
				str_value = cond[i].value; 
				value_condition.comp = cond[i].comp;
			}
			//second encounter of value comparator, if value is not the same for equality, or value is the same but condition differs
			//this is an error and leads to empty set
			else if ( (strcmp( str_value.c_str(), cond[i].value ) !=0) || (value_condition.comp != cond[i].comp) )
			{ isEmptySet = true; }
		}
		
		//exit if there is a NE condition
		if(cond[i].comp == SelCond::NE)
		{
			doIndex = false;
			i = cond.size();  //BS Hack to make sure loop is exited
		}
	}
	
	//cout<<"l_bound: " << l_bound << "\t u_bound: " << u_bound << "\t keyEqual: " << keyEqual << endl;
	
	//if bounds are not proper, then the query returns empty set
	if( (u_bound != -1) && (l_bound != -1) && (u_bound < l_bound) )
	{ isEmptySet = true; }
	else if( keyEqual != -1 )
	{
		//keyEqual is beyond bound
		if( (l_bound != -1 ) && (keyEqual < l_bound) )
		{ isEmptySet = true; }
		else if ( (u_bound != -1 ) && (keyEqual > u_bound) ) 
		{ isEmptySet = true; }
	}
	
	if(isEmptySet)
	{
		//cout<<"empty set"<<endl;
		goto exit_select;
	}
	
	if(doIndex && isIndex)
	{
		IndexCursor	cursor;
		RecordId	rid;
		count = 0;
			
		//if keyEqual != -1 then just print one tuple that meets the equal on key 
		//i.e key = 10
		if( keyEqual != -1 )
		{
			bti.locate(keyEqual, cursor);
			bti.readForward(cursor, key, rid);
			rf.read(rid, key, value);

			
			//IMPORTANT!! Check if the key returned is not equal to key searched, this should not be printed under equality
			if(keyEqual != key)
			{
				cout<<"keyEqual != key" <<endl;
			}
			//If value attribute condition does not exist, or the value attribute condition matches 
			else if( (!haveAttrValue) || (strcmp(value.c_str(), str_value.c_str()) == 0) ) 
			{
				//if a condition on value exists
				if(haveAttrValue)
				{
					//value 	-> retrieved tuple's value
					//str_value -> condition value  
					diff = strcmp(value.c_str(), str_value.c_str());
					printTuple = check_cond(value_condition, diff);				
				}

				if(printTuple)
				{
					if(attr != 4) { print_tuple(attr, key, value); }
					else          { count++; }
				} 		
			}
			
		}
		//if there is a range
		else
		{
			//decide which key to locate
			if(l_bound == -1) { key = 0; }
			else 			  { key = l_bound;}
			
			//locate the first key
			bti.locate(key, cursor);
			
			//go until the end or upperBound
			while( bti.readForward(cursor, key, rid) == 0 )
			{
				if( (u_bound != - 1) && (key > u_bound) )
				{ goto exit_select; }
					
				rf.read(rid, key, value);

				//if a condition on value exists
				if(haveAttrValue)
				{
					//value 	-> retrieved tuple's value
					//str_value -> condition value  
					diff = strcmp(value.c_str(), str_value.c_str());
					printTuple = check_cond(value_condition, diff);					
				}
				
				if(printTuple)
				{
					if(attr != 4) { print_tuple(attr, key, value); }
					else          { count++; }
				} 		
			}
		}
		
		// print matching tuple count if "select count(*)"
		if (attr == 4) 
		{
			fprintf(stdout, "%d\n", count);
		}

	}
	//When not using BTreeIndex, scan the whole table
	else
	{
		// scan the table file from the beginning
		rid.pid = rid.sid = 0;
		count = 0;
		while( rid < rf.endRid() ) 
		{
			// read the tuple
			if ((rc = rf.read(rid, key, value)) < 0) 
			{
				fprintf(stderr, "Error: while reading a tuple from table %s\n", table.c_str());
				goto exit_select;
			}

			// check the conditions on the tuple
			for (unsigned i = 0; i < cond.size(); i++) 
			{
				// compute the difference between the tuple value and the condition value
				switch (cond[i].attr) 
				{
					case 1:
						diff = key - atoi(cond[i].value);
						break;
					case 2:	
						diff = strcmp(value.c_str(), cond[i].value);
						break;
				}

				// skip the tuple if any condition is not met
				switch (cond[i].comp) 
				{
					case SelCond::EQ:
						if (diff != 0) goto next_tuple;
						break;
					case SelCond::NE:
						if (diff == 0) goto next_tuple;
						break;
					case SelCond::GT:
						if (diff <= 0) goto next_tuple;
						break;
					case SelCond::LT:
						if (diff >= 0) goto next_tuple;
						break;
					case SelCond::GE:
						if (diff < 0) goto next_tuple;
						break;
					case SelCond::LE:
						if (diff > 0) goto next_tuple;
						break;
				}
			}

		    // the condition is met for the tuple. 
		    // increase matching tuple counter
		    count++;

		    // print the tuple 
		    switch (attr) 
			{
				case 1:  // SELECT key
					fprintf(stdout, "%d\n", key);
					break;
				case 2:  // SELECT value
					fprintf(stdout, "%s\n", value.c_str());
					break;
				case 3:  // SELECT *
					fprintf(stdout, "%d '%s'\n", key, value.c_str());
					break;
		    }

			// move to the next tuple
		    next_tuple:
		    ++rid;
		}

		// print matching tuple count if "select count(*)"
		if (attr == 4) 
		{
			fprintf(stdout, "%d\n", count);
		}
	}
	
	rc = 0;

	// close the table file and return
	exit_select:
	rf.close();
	bti.close();
	return rc;
	
}

RC SqlEngine::load(const string& table, const string& loadfile, bool index)
{
 
	BTreeIndex bti;
	RecordFile currentRecord;
	RecordId   rid;
	RC         rc; 

	//create a RecordFile name 'table'
	if ((rc = currentRecord.open(table + ".tbl", 'w')) < 0)
	{
		fprintf(stderr, "Error: table %s does not exist\n", table.c_str());
		return rc;
	}
	
	// if index is true, open an index file
	if(index) 
	{ 
		if(( rc = bti.open(table ,'w')) < 0 ) 
		{
			fprintf(stderr, "Error: problem opening index %s \n", table.c_str());
			return rc;
		}  
	}
  
	fstream file;

	int strSize = loadfile.length();
	int temp = 0;

	char theFile[100]; 

	while(temp < strSize)
	{
		theFile[temp] = loadfile[temp];    
		temp++;
	}  

	theFile[temp] = '\0';
	file.open( theFile );
  
	if( !file ) 
	{
		fprintf(stderr, "Error opening input stream");
		return RC_FILE_OPEN_FAILED;
	}
  
	int    key;
	int 	 counter = 0;
	string value;
	string line;

	//extract a line from file
	while( getline(file,line) )
	{
		//extract (key,value) pair from the line
		parseLoadLine(line, key, value);  
		currentRecord.append(key, value, rid);
	
		//insert index
		if(index)
		{
			bti.insert(key, rid);
			counter++;
			//cout<<"inserting key: " << key << " : " << bti.insert(key, rid) << " treeHeight: " << bti.getTreeHeight() << endl;
		}
	}
  
	file.close();
	currentRecord.close();
   
	if(index)  
	{	
		//bti.print_nodes();
		//bti.test_readForward(0);
		bti.close();
		//cout << "there were : " << counter << " inserts" << endl;
		//cout << "end SqlEngine::load treeHeight is: " << bti.getTreeHeight() << endl;
	}
  
	return 0;
}


RC SqlEngine::parseLoadLine(const string& line, int& key, string& value)
{
    const char *s;
    char        c;
    string::size_type loc;
    
    // ignore beginning white spaces
    c = *(s = line.c_str());
    while (c == ' ' || c == '\t') { c = *++s; }

    // get the integer key value
    key = atoi(s);

    // look for comma
    s = strchr(s, ',');
    if (s == NULL) { return RC_INVALID_FILE_FORMAT; }

    // ignore white spaces
    do { c = *++s; } while (c == ' ' || c == '\t');
    
    // if there is nothing left, set the value to empty string
    if (c == 0) { 
        value.erase();
        return 0;
    }

    // is the value field delimited by ' or "?
    if (c == '\'' || c == '"') {
        s++;
    } else {
        c = '\n';
    }

    // get the value string
    value.assign(s);
    loc = value.find(c, 0);
    if (loc != string::npos) { value.erase(loc); }

    return 0;
}


/*

			//if there is no upperBound, go from this located key up to the end
			if( u_bound == -1)
			{
				//go until the end
				while( bti.readForward(cursor, key, rid) = 0 )
				{

					if( (u_bound != - 1) && (key > u_bound)  )
					{ goto exit_select; }
					
					rf.read(rid, key, value);
					print_tuple(attr, key, value);
				}
						
			}
			//if there is an upperBound, so range is defined from key to u_bound
			else
			{
		
				//go until upperBound is reached
				while( bti.readForward(cursor, key, rid) = 0 )
				{
					cout<<"key: " << key << "\t u_bound: " << u_bound << endl;
					
					if ( key > u_bound )
					{ goto exit_select; }

					rf.read(rid, key, value);
					print_tuple(attr, key , value);			
				}			
				
			}


*/




		/*
		else if ( (cond[0].comp == SelCond::GT) || (cond[0].comp == SelCond::GE) )
		{
			while( bti.readForward(cursor, key, rid) >= 0 )
			{
				rf.read(rid, key, value);
				//Print tuples with key > or >= keyValue depending on comparator
				if( (keyValue != key ) || (cond[0].comp == SelCond::GE) )
				{
					print_tuple(attr, key, value); 
				}
			}
		}
		else if ( (cond[0].comp == SelCond::LT) || (cond[0].comp == SelCond::LE) )
		{
			key = 0;
			bti.locate(key, cursor);
			while( key < keyValue )
			{
				bti.readForward(cursor, key, rid);
				rf.read(rid, key, value);
				//Print tuples with key Less Than or Less Than Or Equal keyValue depending on comparator
				if( (keyValue != key) || (cond[0].comp == SelCond::LE) )
				{
					print_tuple(attr, key, value); 
				}
			}
		}
		*/
